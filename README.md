# erisapfel
 A split and discordant derived structural variant breakpoint identifier for evolved populations. 

_Important note for NYU Prince users:
 Load all necessary modules via:
	 source module_load.sh_

## How to use:
 For demonstration use:
  ```
  python erisapfel.py -demo
  ```
 To run an install test using defaults, use:
 ```
 python erisapfel.py -test
 ```

## Commands:
 ### -make
 * Purpose: Generates the required split and discordant sam files from fastq files. Should be ran once for the ancestor strain and once for each evolved strain.
  * Format:
 ```
  erisapfel.py -make -fa <genome fasta file> -fastq_1 <fastq file> -fastq_2 <fastq file> -run_name <output prefix>
 ```
 <!-- * Demo, makes ancestor split and discordant read files:
 ```
  python erisapfel.py -fa demo/input/demo.fna -fastq_1 demo/input/n01_ancestor.fastq.gz -fastq_2 demo/input/n02_ancestor.fastq.gz -run_name demo/output/demo_anc
  ```
  * Demo, makes ancestor split and discordant read files: 
 ```
 python erisapfel.py -make -fa demo/input/demo.fna -fastq_1 demo/input/n01_evolved.fastq.gz -fastq_2 demo/input/n02_evolved.fastq.gz -run_name demo/output/demo_evo
 ```
--->
 
 #### Notes:
 * Analysis of discordant reads requires Paired End reads.

### -depth
* Purpose: Calculates read depth statistics over chrosomes. Negative filtering can be performed wherein reads within a given region are not counted. This is helpful for removing aberrant depths generated from multiple copy regions such as transposons and rDNA or low-complexity regions such as telomeres.  
* Format: 
 ```
python erisapfel.py -depth -filter_bed <filter_bed_format_file> -run_name <output prefix>
 ```
### -peaks
* Purpose: Uses the split and discordant reads generated by the -make command to identify regions in the genome with high levels of split and discordant reads. Should be ran once for the ancestor strain and once for each evolved strain. After the ancestor breakpoint files are generated these should be used in the generation of a filter file using the -filter command. 
* Format: 
 ```
 python erisapfel.py -peaks -run_name <output prefix>
 ```
  <!--* Demo, makes breakpoints for ancestor, no filter is used:
 ```
 python erisapfel.py -breakpoint -i demo/output/demo_anc -break_tab demo/output/demo_ancestor.tab -break_bed bed demo/output/demo_ancestor.bed
 ```
 * Demo, makes breakpoints for evolved, filter is used: 
 ```
 python erisapfel.py -breakpoint -load_filter demo/output/filter.p -i demo/output/demo_evo -break_tab demo/output/demo_evolved.tab -break_bed demo/output/demo_evolved.bed
 ```

 #### Notes:
* (-load_filter <filter_file >)
			The optional -load_filter command should be when generating breakpoints for evolved strains. Ideally, the filter has been generated using the ancestor strain and thus numerous potential sequencing artifacts can be removed at this step. Refer to the -filter command for more information.
* (-no_disco)
			The optional -no_disco command allows you to generate breakpoints only using split-reads. This goes beyond merely weighting discordant reads to zero, as this option prevents them from being loaded into memory. Useful for troubleshooting large or noisy datasets, but not recommended for sensitive analysis.
* (-score 10 | <integer> )
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -score command allows you to set the cutoff to any integer.
* (-sw 1 | <integer>)
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -sw command allows you to set the split read weight to any integer.
* (-dw 3 | <integer>)
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -dw command allows you to set the discordant read weight to any integer.
--->

### -filter
* Purpose: Sequencing artifacts can make identification of breakpoints difficult. By constructing a filter using the ancestor (ie. a genetic background that lacks CNVs) these artifacts can be identified and removed before further analysis. 
* Format:
<!--
python erisapfel.py -filter -filter_bed /scratch/ps163/erisapfel/filter_telomeres.bed -o ${sample_name}_filter.p
--->
```
python erisapfel.py -filter -filter_bed <filter_bed_format_file> -o <sample_name>_filter.p
```
<!--* Demo, filter constructed using both a gff and an ancestor bed file:
```
python erisapfel.py -filter -gff demo/input/demo_filter.gff -ancestor demo/output/demo_ancestor.bed -o demo/output/filter.p
```
#### Notes:
* (-gff <gff_file>)
			This is not the genome gff file. This is the gff of regions that will be filtered. Regions present in this file will be added to the filter. If an ‘ID=’ is present for the record it will be reported in the summary output.
* (-ancestor <break_bed file 1> <break_bed file 2> … < break_bed file n>)
			The optional -ancestor command can accept multiple break_bed files as input. Any breakpoint reported in these files will be added to the filter. All ancestor breakpoints are reported in the summary report using the name of the file they originated in.
--->
### -map
* Purpose: Maps discordant and splitreads into reference genome to generate candidate breakpoints. If filtering is used breakpoints that fall within filtered regions will not be propagated downstream.
* Format:
```
python erisapfel.py -map -run_name <output prefix> [optional --load_filter <sample_name>_filter.p]
```

### -localseq
* Purpose: This command collects all split and discordant reads that align to a given breakpoint region and then passes them on to velvet to construct a local sequence contig. 
* Format: 
```
python erisapfel.py -localseq -run_name <output prefix>
```
<!--
* Demo:
```
python erisapfel.py -localseq -break_tab demo/output/demo_evolved.tab -break_bed demo/output/demo_evolved.bed -fastq_1 demo/input/n01_evolved.fastq.gz -fastq_2 demo/input/n02_evolved.fastq.gz -o demo/input/localseq_evo
```
#### Notes:
* (-split_only)
			This optional command will only load split reads, all contigs will derive from these reads. This is beneficial for handling regions with high numbers of discordant reads, as it cuts down processing and can reduce the noise in the generated contigs.
* (-hashsize 15 | int) 
* (-min_contig 25 | int ) 
* (-max_divergence 0.05 | decimal from 0-1)
* (-cov_cutoff 1 | int)
		Several optional commands are supported that allow for the tuning of the underlying velvet parameters. In all cases one should refer to the velvet documentation for more detail. 
			-hashsize sets the kmer size for the hashtable. 
			-min_contig sets the smallest allowable contig size, note changing this size will require a subsequent re-evaluation in -hashisize. 
			-max_divergence sets the limit for velvet’s alignment simplification step. If two sequences are more diverged than this value (greater sequence divergence than 5% using our default) than they are not simplified (ie. combined and reduced). Increasing this value increases the number of sequences simplified.
			-cov_cutoff sets the minimum number of supporting reads required to be reported. By default we have set this to one.

### -realign
* Purpose: In this step we realign all local sequence contigs to the reference genome using blastn. These realignments are then output as a gff file. Each row of the gff contains the region the contig mapped to as well as the original contig sequence (contig=), the reference sequence (ref_seq=), and the aligned component of the contig (alt_seq=). These can be used to recreate the underlying architecture of the breakpoint region.
* Format:
```
python erisapfel.py -realign -fa <reference fasta> -contigs <localseq directory> [-min_coverage 1.5 | float] [-max_eval 0.05 | float] -o <output prefix>
```
* Demo:
```
python erisapfel.py -realign -fa demo/input/demo.fna -contigs demo/input/localseq_evo/ -o demo/input/localseq_evo/realign_evo
```
#### Notes:
* (-min_coverage 1.5 | float)
			This optional command allows you to modify the minimum number of reads required to for a contig to be aligned to reference genome.
* (-max_eval 0.05 | float)
			This optional command allows you to set the highest E value allowed for a realignment to be considered. This field supports scientific notation (eg. 0.05, 5e-2).
--->

