# CVish
A **C**opy Number **V**ariant and Structural Variant finder for short read sequencing that uses split and discordant reads as well read depth to identify potential breakpoints. 

_Important note for NYU HPC users:
 Load all necessary modules via:
	 source module_load.sh_

## Requirements
CVish intends to be a requirement lite tool and as such is contained entirely in single python script. 
It does require the following programs to be installed in the environment:

python		(tested on version: 3.8.6)
bwa		(tested on version: 0.7.17)
samtools	(tested on version: 1.14)
bedtools	(tested on version: 2.29.2)
blast		(tested on version: 2.11.0)
samblaster	(tested on version: 0.1.26)
mafft		(tested on version: 7.475)
emboss		(tested on version: 6.6.0)

<!--
## How to use:
 For demonstration use:
  ```
  python erisapfel.py -demo
  ```
 To run an install test using defaults, use:
 ```
 python erisapfel.py -test
 ```
--->

## Commands:
 ### -make
 * Purpose: Generates the required split and discordant sam files from fastq files. Should be ran once for the ancestor strain and once for each evolved strain.
  * Format:
 ```
  erisapfel.py -make -fa <genome fasta file> -fastq_1 <fastq file> -fastq_2 <fastq file> -run_name <output prefix>
 ```
 <!-- * Demo, makes ancestor split and discordant read files:
 ```
  python erisapfel.py -fa demo/input/demo.fna -fastq_1 demo/input/n01_ancestor.fastq.gz -fastq_2 demo/input/n02_ancestor.fastq.gz -run_name demo/output/demo_anc
  ```
  * Demo, makes ancestor split and discordant read files: 
 ```
 python erisapfel.py -make -fa demo/input/demo.fna -fastq_1 demo/input/n01_evolved.fastq.gz -fastq_2 demo/input/n02_evolved.fastq.gz -run_name demo/output/demo_evo
 ```
--->
 
 #### Notes:
 * Analysis of discordant reads requires Paired End reads.

### -depth
* Purpose: Calculates read depth statistics over chrosomes.  
* Format: 
 ```
python erisapfel.py -depth -run_name <output prefix>
 ```
 Optional:  Positive filtering can be performed, wherein only reads within a given region are counted. This is helpful for removing aberrant depths generated from multiple copy regions such as transposons and rDNA.
 ```
#Optional -positive filter 
python erisapfel.py -depth -filter_bed <filter_bed_format_file> -run_name <output prefix>
 ```
### -peaks
* Purpose: Uses the split and discordant reads generated by the -make command to identify regions in the genome with high levels of split and discordant reads. Should be ran once for the ancestor strain and once for each evolved strain. After the ancestor breakpoint files are generated these should be used in the generation of a filter file using the -filter command. 
* Format: 
 ```
 python erisapfel.py -peaks -run_name <output prefix>
 ```
  <!--* Demo, makes breakpoints for ancestor, no filter is used:
 ```
 python erisapfel.py -breakpoint -i demo/output/demo_anc -break_tab demo/output/demo_ancestor.tab -break_bed bed demo/output/demo_ancestor.bed
 ```
 * Demo, makes breakpoints for evolved, filter is used: 
 ```
 python erisapfel.py -breakpoint -load_filter demo/output/filter.p -i demo/output/demo_evo -break_tab demo/output/demo_evolved.tab -break_bed demo/output/demo_evolved.bed
 ```

 #### Notes:
* (-load_filter <filter_file >)
			The optional -load_filter command should be when generating breakpoints for evolved strains. Ideally, the filter has been generated using the ancestor strain and thus numerous potential sequencing artifacts can be removed at this step. Refer to the -filter command for more information.
* (-no_disco)
			The optional -no_disco command allows you to generate breakpoints only using split-reads. This goes beyond merely weighting discordant reads to zero, as this option prevents them from being loaded into memory. Useful for troubleshooting large or noisy datasets, but not recommended for sensitive analysis.
* (-score 10 | <integer> )
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -score command allows you to set the cutoff to any integer.
* (-sw 1 | <integer>)
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -sw command allows you to set the split read weight to any integer.
* (-dw 3 | <integer>)
			Breakpoints are required to meet a threshold quality score cutoff. By default a breakpoint cutoff of 10, with a split weight (sw) of 1 and a discordant weight (dw) of 3, will require a minimum of one split-read and three supporting discordant reads. The optional -dw command allows you to set the discordant read weight to any integer.
--->

### OPTIONAL -filter
* Purpose: This step generates a filter region pickle file using bed formatted input. These are negative filters, wherein breakpoints within these regions will be removed from further analysis. One may desire to avoid these regions because of highly repetitive sequences (rDNA, Mitochondria) or low-complexity sequences (Telomeres). 
Sequencing artifacts can make identification of breakpoints difficult. By constructing a filter using a bed file generated using an ancestor (ie. a genetic background that lacks CNVs) these artifacts can be readily identified and removed before further analysis. 
* Format:
<!--
python erisapfel.py -filter -filter_bed /scratch/ps163/erisapfel/filter_telomeres.bed --filter_object ${sample_name}_filter.p
--->
```
python erisapfel.py -filter -filter_bed <filter_bed_format_file> --filter_object <sample_name>_filter.p
```
<!--* Demo, filter constructed using both a gff and an ancestor bed file:
```
python erisapfel.py -filter -gff demo/input/demo_filter.gff -ancestor demo/output/demo_ancestor.bed -o demo/output/filter.p
```
#### Notes:
* (-gff <gff_file>)
			This is not the genome gff file. This is the gff of regions that will be filtered. Regions present in this file will be added to the filter. If an ‘ID=’ is present for the record it will be reported in the summary output.
* (-ancestor <break_bed file 1> <break_bed file 2> … < break_bed file n>)
			The optional -ancestor command can accept multiple break_bed files as input. Any breakpoint reported in these files will be added to the filter. All ancestor breakpoints are reported in the summary report using the name of the file they originated in.
--->
### -map
* Purpose: Maps discordant and splitreads into reference genome to generate candidate breakpoints. 
* Format:
```
python erisapfel.py -map -run_name <output prefix> 
```
Optional: If filtering is used breakpoints that fall within filtered regions will not be propagated downstream.
```
python erisapfel.py -map -run_name <output prefix>  --filter_object <sample_name>_filter.p
```

### -localseq
* Purpose: This command collects all split and discordant reads that align to a given breakpoint region and then passes them on to velvet to construct a local sequence contig. 
* Format: 
```
python erisapfel.py -localseq -run_name <output prefix>
```
<!--
* Demo:
```
python erisapfel.py -localseq -break_tab demo/output/demo_evolved.tab -break_bed demo/output/demo_evolved.bed -fastq_1 demo/input/n01_evolved.fastq.gz -fastq_2 demo/input/n02_evolved.fastq.gz -o demo/input/localseq_evo
```
#### Notes:
* (-split_only)
			This optional command will only load split reads, all contigs will derive from these reads. This is beneficial for handling regions with high numbers of discordant reads, as it cuts down processing and can reduce the noise in the generated contigs.
* (-hashsize 15 | int) 
* (-min_contig 25 | int ) 
* (-max_divergence 0.05 | decimal from 0-1)
* (-cov_cutoff 1 | int)
		Several optional commands are supported that allow for the tuning of the underlying velvet parameters. In all cases one should refer to the velvet documentation for more detail. 
			-hashsize sets the kmer size for the hashtable. 
			-min_contig sets the smallest allowable contig size, note changing this size will require a subsequent re-evaluation in -hashisize. 
			-max_divergence sets the limit for velvet’s alignment simplification step. If two sequences are more diverged than this value (greater sequence divergence than 5% using our default) than they are not simplified (ie. combined and reduced). Increasing this value increases the number of sequences simplified.
			-cov_cutoff sets the minimum number of supporting reads required to be reported. By default we have set this to one.

### -realign
* Purpose: In this step we realign all local sequence contigs to the reference genome using blastn. These realignments are then output as a gff file. Each row of the gff contains the region the contig mapped to as well as the original contig sequence (contig=), the reference sequence (ref_seq=), and the aligned component of the contig (alt_seq=). These can be used to recreate the underlying architecture of the breakpoint region.
* Format:
```
python erisapfel.py -realign -fa <reference fasta> -contigs <localseq directory> [-min_coverage 1.5 | float] [-max_eval 0.05 | float] -o <output prefix>
```
* Demo:
```
python erisapfel.py -realign -fa demo/input/demo.fna -contigs demo/input/localseq_evo/ -o demo/input/localseq_evo/realign_evo
```
#### Notes:
* (-min_coverage 1.5 | float)
			This optional command allows you to modify the minimum number of reads required to for a contig to be aligned to reference genome.
* (-max_eval 0.05 | float)
			This optional command allows you to set the highest E value allowed for a realignment to be considered. This field supports scientific notation (eg. 0.05, 5e-2).
--->

## Output Analysis 
After the run has completed several resulting files should be analyzed to help determine likely breakpoints.

All files are located in the ```results/<sample_name>/``` directory.

### Bams 
Discordant and split reads are subset in their own bam files, viewable in the ```/results/<sample_name>/bam/``` directory. Files that may be of interest are:
```
<sample_name>.bam - Complete, aligned reads bam
<sample_name>.bedGraph - bedgraph of complete, aligned bam
<sample_name>_discordant.bam - Discordant reads bam
<sample_name>_split.bam - Split reads bam
```

### Breakpoint feature files
Resolved high confidence breakpoints are reported as features in the ```/results/<sample_name>/output/``` directory. 

```
DGY3_realigned.gff - Final candidate list, with scores and breakpoint sequence 
```

## How to make sense of the results in the _realigned.gff_ file
The _realigned.gff_ file follows a simple convention for highlighting breakpoints. Each breakpoint has at least two components: an anchor and a breezepoint. The anchor, by definition, contains a uniquely mapping sequence. Conversely, the breezepoint can map to numerous places with no restriction, this allows for potential breezepoints to map to repeat or low-complexity regions, such as gene homologs and transposon elements.

When possible the assemdbled contig that generated the breakpoint is included.

### Example _realigned.gff_

```
[chromosome]    [source]    [unique_id]   [start]   [stop]    [dot] [dot]   [score]   [details]
I   erisapfel   7458_anchor_split	39821    39905   .   .   698    node_uid=7458;otherside=NC_001147.6:1091237-1091291_breeze;contig=CACACACACCACACCCACACACCCACACACCACACCCACACACTCTCTCACATCTACCTCTACTCTCGCTGTCAT
IV   erisapfel   7458_breeze_split   1091237   1091291   .   .   698    node_uid=7458_anchor;otherside=NC_001144.5:30-111;contig=CACACACACCACACCCACACACCCACACACCACACCCACACACTCTCTCACATCTACCTCTACTCTCGCTGTCAT
```
In this example the proposed breakpoint "7458" spans from chrI:30-111 (anchor) to chrIV:1091237-1091291 (breezepoint). It has a score of 698 and would be reported using the default _min_score_.

# Note on performance
Erisapfel performs best with breakpoints spanning unique sequences and at sufficient depth (~30x depth). For lower depths of sequencing or breakpoints that occur in low-complexity or non-unique sequences this performance will suffer.  For breakpoints that are associated with transposons or other known mobile genetic elements, detection can be improved by using Erisapfel's MGE mode.
